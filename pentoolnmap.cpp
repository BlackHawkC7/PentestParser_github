#include "pentoolnmap.h"

PenToolNmap::PenToolNmap()
{
    //connects for QProcess
    connect(&process, &QProcess::stateChanged, this, &PenToolNmap::processStatusChanged);
    connect(&process, &QProcess::errorOccurred, this, &PenToolNmap::processError);
    connect(&process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished), this, &PenToolNmap::processFinished);
}

PenToolNmap::PenToolNmap(QString inputFilePath)
{
    QFile f(inputFilePath);
    if(!f.open(QIODevice::ReadOnly)) {
        qInfo() << "ERROR: loading input file failed";
        return;
    }
    this->xmlFile.setContent(&f);
    f.close();
}


void PenToolNmap::parse(QString resultFileFormat)
{
    if(xmlFile.isNull()) {
        qInfo() << "ERROR: loading xml failed";
        return;
    }
    QDomElement root = this->xmlFile.documentElement();

    //start time
    QDateTime startTimestamp;
    startTimestamp.setTime_t(root.attribute("start").toUInt());
    result.setStartTimestamp(startTimestamp);

    //stop time
    QDateTime stopTimestamp;
    stopTimestamp.setTime_t(root.elementsByTagName("runstats").at(0).toElement().elementsByTagName("finished").at(0).toElement().attribute("time").toUInt());
    result.setStopTimestamp(stopTimestamp);

    //duration
    result.setTestDuration(startTimestamp.secsTo(stopTimestamp));

    //nmap info
    result.setNmapVersion(root.attribute("version"));
    result.setRunAttributes(root.attribute("args"));

    //nmapdone message
    QDomElement output = root.elementsByTagName("output").at(0).toElement();
    result.setDoneMessage(output.text().mid(output.text().indexOf("Nmap done:"), -1).simplified());

    //HOSTS list
    QDomNodeList hostNodeList = root.elementsByTagName("host");

    //hosts
    QList<host> hostList;
    for(int i=0; i<hostNodeList.size(); i++) {
        QDomElement hostElement = hostNodeList.at(i).toElement();
        host newHost;

        //addresses (ip or mac)
        QDomNodeList addressNodeList = hostElement.elementsByTagName("address");
        for(int j=0; j<addressNodeList.size(); j++) {
            QDomElement actualAddress = addressNodeList.at(j).toElement();
            if(actualAddress.attribute("addrtype") == "ipv4")
                newHost.ipAddress = actualAddress.attribute("addr");

            if(actualAddress.attribute("addrtype") == "mac") {
                newHost.macAddress = actualAddress.attribute("addr");
                newHost.vendor = actualAddress.attribute("vendor");
            }
        }

        QDomNodeList portNodeList = hostElement.elementsByTagName("port");
        //host ports
        QList<port> portList;
        for(int j=0; j<portNodeList.size(); j++) {
            QDomElement portServiceElement = portNodeList.at(j).toElement().elementsByTagName("service").at(0).toElement();
            QDomElement portStateElement = portNodeList.at(j).toElement().elementsByTagName("state").at(0).toElement();
            port newPort;

            newPort.number = portNodeList.at(j).toElement().attribute("portid").toUInt();
            newPort.protocol = portNodeList.at(j).toElement().attribute("protocol");
            newPort.state = portStateElement.attribute("state");
            newPort.service = portServiceElement.attribute("product");
            newPort.serviceName = portServiceElement.attribute("name");
            newPort.serviceVersion = portServiceElement.attribute("version");

            portList.append(newPort);
        }
        newHost.portList = portList;

        //host OS
        QDomNodeList osNodeList = hostElement.elementsByTagName("os");
        QDomNodeList osmatchList = osNodeList.at(0).toElement().elementsByTagName("osmatch");

        QList<os> osList;
        for(int j=0; j<osmatchList.size(); j++) {
            QDomElement osmatchElement = osmatchList.at(j).toElement();
            os newOs;

            newOs.name = osmatchElement.attribute("name");
            newOs.accuracy = osmatchElement.attribute("accuracy").toUInt();

            osList.append(newOs);
        }
        newHost.osList = osList;

        //uptime
        QDomElement uptimeElement = hostElement.elementsByTagName("uptime").at(0).toElement();
        newHost.uptime = uptimeElement.attribute("seconds").toUInt();

        //tracert
        QDomElement traceElement = hostElement.elementsByTagName("trace").at(0).toElement();
        QDomNodeList hopNodeList = traceElement.elementsByTagName("hop");

        newHost.networkDistance = hopNodeList.size();
        QList<hop> hopList;
        for(int j=0; j<hopNodeList.size(); j++) {
            QDomElement hop = hopNodeList.at(j).toElement();
            struct hop newHop;

            newHop.rtt = hop.attribute("rtt").toDouble();
            newHop.ipAddress = hop.attribute("ipaddr");
            hopList.append(newHop);
        }
        newHost.hopList = hopList;

        hostList.append(newHost);
    }
    result.setHostList(hostList);

    if(resultFileFormat == "xml")
        result.toXmlFile();
    else if(resultFileFormat == "json")
        result.toJsonFile();
}

void PenToolNmap::run(QString nmapFolderPath, QString runArguments)
{
    //nmap [ <Scan Type> ...] [ <Options> ] { <target specification> }

    /*
    QString scanType = " -A";
    QString options = " -p 1-100";
    QString targetSpecification = " 192.168.1.1";
    */

    //QString nmapDirectory = QCoreApplication::applicationDirPath()+"/nmap/";
    //this->process.setWorkingDirectory(nmapDirectory);


    //QFileInfo checkFile(nmapFolderPath + "7za.exe");

#ifdef _WIN32
    this->process.start(nmapFolderPath + "nmap.exe" + runArguments.prepend(" "));
#endif

#ifdef __linux__
    this->process.start(nmapFolderPath + "nmap" + runArguments.prepend(" "));
#endif

    //this->process.waitForStarted();
    qInfo() << "STATUS: waiting for finished";
    this->process.waitForFinished();
    process.exitCode();//TODO

    QFile f(nmapFolderPath + "result.xml");
    if(!f.open(QIODevice::ReadOnly)) {
        qInfo() << "ERROR: loading input file failed";
        return;
    }
    this->xmlFile.setContent(&f);
    f.close();
}

void PenToolNmap::processStatusChanged(QProcess::ProcessState state)
{
    switch(state) {
    case QProcess::NotRunning:
        break;
    case QProcess::Starting:
        qInfo() << "STATUS: nmap starting";
        break;
    case QProcess::Running:
        qInfo() << "STATUS: nmap running";
        break;
    }
}

void PenToolNmap::processFinished(int exitCode, QProcess::ExitStatus exitStatus)
{
    switch(exitStatus) {
    case QProcess::CrashExit:
        qInfo() << "ERROR: nmap crashed, exit code: " << exitCode;
        break;
    case QProcess::NormalExit:
        qInfo() << "STATUS: nmap finished";
        break;
    }
}

void PenToolNmap::processError(QProcess::ProcessError error)
{
    qInfo() << "ERROR: nmap running failed";
    qInfo() << "ERROR: " << error;
}
